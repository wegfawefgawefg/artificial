Sprites & Animation Plan
========================

Summary
-------
- Current: `SpriteIdRegistry` stores only names→IDs and an ID→name list. No image paths, frames, timing, or offsets.
- Goal: Support static and animated sprites described by an image plus one or more frames (rects in the image), frame timing (fps or per-frame durations), looping, and render pivot/offset. Hot-reload when assets/manifests change.

Requirements
------------
- Static sprite: single frame using the whole image by default.
- Animated sprite: multiple frames with either a global fps or per-frame durations; loop flag.
- Frame rects: x,y,w,h offsets into the image.
- Pivot/offset: pixel-space pivot point for rendering alignment; optional world-space offset (default 0).
- Hot reload: Detect changes in `mods/*/graphics/` and rebuild definitions without changing numeric IDs for existing names.
- Backward fallback: If no manifest exists for an image, treat it as a single-frame sprite.

Data Model
----------
- Frame: `{ int x, int y, int w, int h, float duration_sec }` (duration may be 0 if using global fps)
- SpriteDef:
  - `std::string name`
  - `std::string image_path` (relative to mod root or absolute)
  - `std::vector<Frame> frames`
  - `bool loop`
  - `float fps` (0 means use per-frame `duration_sec`)
  - `int pivot_px_x`, `int pivot_px_y` (default = frame center)
  - `float world_offset_x`, `float world_offset_y` (default 0; optional)
  - Derived helpers for total length and frame lookup
- SpriteStore:
  - Keyed by sprite name and by ID
  - Holds `std::unordered_map<std::string,int> name_to_id`, `std::vector<SpriteDef> defs_by_id`
  - Cooperates with `SpriteIdRegistry` or replaces it by absorbing name↔ID mapping (prefer absorb to avoid duplication)

Manifest Format
---------------
- Sidecar file per sprite: `name.sprite.toml` (or `.sprite` minimal INI/TOML-like)
- Example (explicit frames):
  name = "slime_walk"
  image = "slime.png"
  fps = 8                 # optional if using per-frame durations
  loop = true
  pivot_px = [8, 12]      # optional; defaults to frame center
  world_offset = [0.0, 0.0]
  frames = [
    [0, 0, 16, 16],
    [16, 0, 16, 16],
    [32, 0, 16, 16],
    [48, 0, 16, 16],
  ]

- Example (grid auto-slice):
  name = "slime_idle"
  image = "slime.png"
  loop = true
  grid = { frame_w=16, frame_h=16, cols=4, rows=1, origin_x=0, origin_y=16 } # optional; builds frames list

- Fallback (no manifest):
  - name = file stem; image = file; frames = single frame covering whole image; loop=false; pivot=center.

Loader Behavior
---------------
- Scan `mods/*/graphics/**` for images and `.sprite(.toml)` manifests.
- If manifest present → parse and build SpriteDef.
- If only image present → create default single-frame SpriteDef.
- Maintain stable IDs by sprite name; add new names at the end; remove orphaned names or keep tombstones depending on need (start with remove and re-pack, but keep name→ID stable when possible).
- On errors: log and skip the faulty sprite; do not crash.

Hot Reload Integration
----------------------
- Extend `ModsManager::build_sprite_registry` → `build_sprite_store(SpriteStore&)`.
- On asset changes detected by `ModsManager::poll_hot_reload`:
  - Re-parse changed manifests or re-scan affected image directories.
  - Rebuild or patch `SpriteStore` while preserving existing name→ID where names persist.
  - Emit concise logs with counts and changed names.

Rendering (Deferred)
--------------------
- Keep current debug-rect rendering.
- When texture system lands:
  - Load images to textures per mod (or atlas packer later).
  - For each entity/projectile with a sprite name/ID, compute current frame index from time and `SpriteDef` and draw using `pivot_px` and `world_offset`.

Milestones
---------
1) Implement `SpriteDef` and `SpriteStore` types (+ parsing helpers).
2) Replace `SpriteIdRegistry` usage with `SpriteStore` but keep a thin name→ID alias for compatibility.
3) Implement manifest parsing (TOML-like; minimal robust parser or simple hand-rolled specific to fields).
4) Integrate with `ModsManager` scans and hot reload.
5) Add basic validation and logging; ensure IDs are stable across reloads.
6) Hook into render path (later) once textures are introduced.

Notes
-----
- Keep integers for IDs to match data-driven philosophy.
- Avoid enums for sprite types; use string names in data, ints in engine.
- Parsing must tolerate comments and whitespace; unknown keys ignored.
